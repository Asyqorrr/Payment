// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: payment_transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllTransactionInfo = `-- name: GetAllTransactionInfo :many
SELECT patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, 
	patrx_acctno_from, patrx_acctno_to, t.traty_name, ua.usac_account_no, usac_balance
	FROM public.payment_transactions
	JOIN transaction_type as t ON t.traty_id = patrx_traty_id
	JOIN user_accounts as ua ON ua.usac_account_no = patrx_acctno_from
`

type GetAllTransactionInfoRow struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxCredit     *float64    `json:"patrx_credit"`
	PatrxNotes      *string     `json:"patrx_notes"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string     `json:"patrx_acctno_to"`
	TratyName       *string     `json:"traty_name"`
	UsacAccountNo   *string     `json:"usac_account_no"`
	UsacBalance     *float64    `json:"usac_balance"`
}

func (q *Queries) GetAllTransactionInfo(ctx context.Context) ([]*GetAllTransactionInfoRow, error) {
	rows, err := q.db.Query(ctx, getAllTransactionInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllTransactionInfoRow
	for rows.Next() {
		var i GetAllTransactionInfoRow
		if err := rows.Scan(
			&i.PatrxNo,
			&i.PatrxCreatedOn,
			&i.PatrxDebet,
			&i.PatrxCredit,
			&i.PatrxNotes,
			&i.PatrxAcctnoFrom,
			&i.PatrxAcctnoTo,
			&i.TratyName,
			&i.UsacAccountNo,
			&i.UsacBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionFrom = `-- name: GetTransactionFrom :many
SELECT patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, 
	patrx_acctno_from, patrx_acctno_to, t.traty_name, ua.usac_account_no, usac_balance
	FROM public.payment_transactions
	JOIN transaction_type as t ON t.traty_id = patrx_traty_id
	JOIN user_accounts as ua ON ua.usac_account_no = patrx_acctno_from
    WHERE patrx_acctno_from = $1
`

type GetTransactionFromRow struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxCredit     *float64    `json:"patrx_credit"`
	PatrxNotes      *string     `json:"patrx_notes"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string     `json:"patrx_acctno_to"`
	TratyName       *string     `json:"traty_name"`
	UsacAccountNo   *string     `json:"usac_account_no"`
	UsacBalance     *float64    `json:"usac_balance"`
}

func (q *Queries) GetTransactionFrom(ctx context.Context, patrxAcctnoFrom *string) ([]*GetTransactionFromRow, error) {
	rows, err := q.db.Query(ctx, getTransactionFrom, patrxAcctnoFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionFromRow
	for rows.Next() {
		var i GetTransactionFromRow
		if err := rows.Scan(
			&i.PatrxNo,
			&i.PatrxCreatedOn,
			&i.PatrxDebet,
			&i.PatrxCredit,
			&i.PatrxNotes,
			&i.PatrxAcctnoFrom,
			&i.PatrxAcctnoTo,
			&i.TratyName,
			&i.UsacAccountNo,
			&i.UsacBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionFromAndTo = `-- name: GetTransactionFromAndTo :many
SELECT patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id
	FROM payment_transactions
WHERE patrx_acctno_from = $1 or patrx_acctno_to = $2
`

type GetTransactionFromAndToParams struct {
	PatrxAcctnoFrom *string `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string `json:"patrx_acctno_to"`
}

func (q *Queries) GetTransactionFromAndTo(ctx context.Context, arg GetTransactionFromAndToParams) ([]*PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, getTransactionFromAndTo, arg.PatrxAcctnoFrom, arg.PatrxAcctnoTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.PatrxNo,
			&i.PatrxCreatedOn,
			&i.PatrxDebet,
			&i.PatrxCredit,
			&i.PatrxNotes,
			&i.PatrxAcctnoFrom,
			&i.PatrxAcctnoTo,
			&i.PatrxPatrxRef,
			&i.PatrxTratyID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionTo = `-- name: GetTransactionTo :many
SELECT patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, 
	patrx_acctno_from, patrx_acctno_to, t.traty_name, ua.usac_account_no, usac_balance
	FROM public.payment_transactions
	JOIN transaction_type as t ON t.traty_id = patrx_traty_id
	JOIN user_accounts as ua ON ua.usac_account_no = patrx_acctno_to
    WHERE patrx_acctno_to = $1
`

type GetTransactionToRow struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxCredit     *float64    `json:"patrx_credit"`
	PatrxNotes      *string     `json:"patrx_notes"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string     `json:"patrx_acctno_to"`
	TratyName       *string     `json:"traty_name"`
	UsacAccountNo   *string     `json:"usac_account_no"`
	UsacBalance     *float64    `json:"usac_balance"`
}

func (q *Queries) GetTransactionTo(ctx context.Context, patrxAcctnoTo *string) ([]*GetTransactionToRow, error) {
	rows, err := q.db.Query(ctx, getTransactionTo, patrxAcctnoTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionToRow
	for rows.Next() {
		var i GetTransactionToRow
		if err := rows.Scan(
			&i.PatrxNo,
			&i.PatrxCreatedOn,
			&i.PatrxDebet,
			&i.PatrxCredit,
			&i.PatrxNotes,
			&i.PatrxAcctnoFrom,
			&i.PatrxAcctnoTo,
			&i.TratyName,
			&i.UsacAccountNo,
			&i.UsacBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setorTransaction = `-- name: SetorTransaction :one
INSERT INTO public.payment_transactions(
	patrx_no, patrx_created_on, patrx_debet, patrx_acctno_from, patrx_acctno_to, patrx_traty_id)
	VALUES ( $1, $2, $3, $4, $5, 1)
    RETURNING patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id
`

type SetorTransactionParams struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string     `json:"patrx_acctno_to"`
}

func (q *Queries) SetorTransaction(ctx context.Context, arg SetorTransactionParams) (*PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, setorTransaction,
		arg.PatrxNo,
		arg.PatrxCreatedOn,
		arg.PatrxDebet,
		arg.PatrxAcctnoFrom,
		arg.PatrxAcctnoTo,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.PatrxNo,
		&i.PatrxCreatedOn,
		&i.PatrxDebet,
		&i.PatrxCredit,
		&i.PatrxNotes,
		&i.PatrxAcctnoFrom,
		&i.PatrxAcctnoTo,
		&i.PatrxPatrxRef,
		&i.PatrxTratyID,
	)
	return &i, err
}

const transfer = `-- name: Transfer :one
INSERT INTO payment_transactions(
	patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id)
	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	RETURNING patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id
`

type TransferParams struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxCredit     *float64    `json:"patrx_credit"`
	PatrxNotes      *string     `json:"patrx_notes"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxAcctnoTo   *string     `json:"patrx_acctno_to"`
	PatrxPatrxRef   *string     `json:"patrx_patrx_ref"`
	PatrxTratyID    *int32      `json:"patrx_traty_id"`
}

func (q *Queries) Transfer(ctx context.Context, arg TransferParams) (*PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, transfer,
		arg.PatrxNo,
		arg.PatrxCreatedOn,
		arg.PatrxDebet,
		arg.PatrxCredit,
		arg.PatrxNotes,
		arg.PatrxAcctnoFrom,
		arg.PatrxAcctnoTo,
		arg.PatrxPatrxRef,
		arg.PatrxTratyID,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.PatrxNo,
		&i.PatrxCreatedOn,
		&i.PatrxDebet,
		&i.PatrxCredit,
		&i.PatrxNotes,
		&i.PatrxAcctnoFrom,
		&i.PatrxAcctnoTo,
		&i.PatrxPatrxRef,
		&i.PatrxTratyID,
	)
	return &i, err
}

const transferReceive = `-- name: TransferReceive :one
INSERT INTO payment_transactions(
	patrx_no, patrx_created_on, patrx_debet, patrx_notes, patrx_acctno_from, patrx_traty_id, patrx_patrx_ref)
	VALUES ($1, $2, $3, $4, $5, $6, $7) 
    RETURNING patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id
`

type TransferReceiveParams struct {
	PatrxNo         string      `json:"patrx_no"`
	PatrxCreatedOn  pgtype.Date `json:"patrx_created_on"`
	PatrxDebet      *float64    `json:"patrx_debet"`
	PatrxNotes      *string     `json:"patrx_notes"`
	PatrxAcctnoFrom *string     `json:"patrx_acctno_from"`
	PatrxTratyID    *int32      `json:"patrx_traty_id"`
	PatrxPatrxRef   *string     `json:"patrx_patrx_ref"`
}

func (q *Queries) TransferReceive(ctx context.Context, arg TransferReceiveParams) (*PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, transferReceive,
		arg.PatrxNo,
		arg.PatrxCreatedOn,
		arg.PatrxDebet,
		arg.PatrxNotes,
		arg.PatrxAcctnoFrom,
		arg.PatrxTratyID,
		arg.PatrxPatrxRef,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.PatrxNo,
		&i.PatrxCreatedOn,
		&i.PatrxDebet,
		&i.PatrxCredit,
		&i.PatrxNotes,
		&i.PatrxAcctnoFrom,
		&i.PatrxAcctnoTo,
		&i.PatrxPatrxRef,
		&i.PatrxTratyID,
	)
	return &i, err
}

const transferSend = `-- name: TransferSend :one
INSERT INTO payment_transactions(
	patrx_no, patrx_created_on, patrx_credit, patrx_notes, patrx_acctno_to, patrx_traty_id)
	VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING patrx_no, patrx_created_on, patrx_debet, patrx_credit, patrx_notes, patrx_acctno_from, patrx_acctno_to, patrx_patrx_ref, patrx_traty_id
`

type TransferSendParams struct {
	PatrxNo        string      `json:"patrx_no"`
	PatrxCreatedOn pgtype.Date `json:"patrx_created_on"`
	PatrxCredit    *float64    `json:"patrx_credit"`
	PatrxNotes     *string     `json:"patrx_notes"`
	PatrxAcctnoTo  *string     `json:"patrx_acctno_to"`
	PatrxTratyID   *int32      `json:"patrx_traty_id"`
}

func (q *Queries) TransferSend(ctx context.Context, arg TransferSendParams) (*PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, transferSend,
		arg.PatrxNo,
		arg.PatrxCreatedOn,
		arg.PatrxCredit,
		arg.PatrxNotes,
		arg.PatrxAcctnoTo,
		arg.PatrxTratyID,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.PatrxNo,
		&i.PatrxCreatedOn,
		&i.PatrxDebet,
		&i.PatrxCredit,
		&i.PatrxNotes,
		&i.PatrxAcctnoFrom,
		&i.PatrxAcctnoTo,
		&i.PatrxPatrxRef,
		&i.PatrxTratyID,
	)
	return &i, err
}
